import Foundation
import CryptoKit
import CoreGraphics
import ImageIO
#if os(macOS)
import AppKit
#else
import UIKit
#endif

// MARK: - Array Extensions

extension Array {
    func chunked(into size: Int) -> [[Element]] {
        return stride(from: 0, to: count, by: size).map {
            Array(self[$0..<Swift.min($0 + size, count)])
        }
    }
}

// MARK: - Global Models


enum HashCalculationError: Error {
    case fileNotAccessible(String)
    case fileNotReadable(String)
    case fileSizeError(String)
    case readError(String)
    case unknownError(String)

    var localizedDescription: String {
        switch self {
        case .fileNotAccessible(let path):
            return "Êó†Ê≥ïËÆøÈóÆÊñá‰ª∂: \(path)"
        case .fileNotReadable(let path):
            return "Êñá‰ª∂‰∏çÂèØËØª: \(path)"
        case .fileSizeError(let path):
            return "Êó†Ê≥ïËé∑ÂèñÊñá‰ª∂Â§ßÂ∞è: \(path)"
        case .readError(let details):
            return "ËØªÂèñÊñá‰ª∂Êó∂Âá∫Èîô: \(details)"
        case .unknownError(let details):
            return "Êú™Áü•ÈîôËØØ: \(details)"
        }
    }
}

// MARK: - Êñ∞ÁöÑ4Èò∂ÊÆµÁÆóÊ≥ïÊï∞ÊçÆÁªìÊûÑ

/// Live PhotoÁßçÂ≠êÁªÑÔºàÈò∂ÊÆµ1ÁöÑÁªìÊûúÔºâ
struct LivePhotoSeedGroup: Identifiable {
    let id = UUID()
    let seedName: String           // Âü∫Á°ÄÊñá‰ª∂Âêç
    var heicFiles: [URL] = []      // HEICÊñá‰ª∂ÂàóË°®
    var movFiles: [URL] = []       // MOVÊñá‰ª∂ÂàóË°®

    var hasCompletePair: Bool {
        return !heicFiles.isEmpty && !movFiles.isEmpty
    }

    var allFiles: [URL] {
        return heicFiles + movFiles
    }
}

/// ÂÜÖÂÆπÁªÑÔºàÈò∂ÊÆµ2-3ÁöÑÁªìÊûúÔºâ
struct ContentGroup: Identifiable {
    let id = UUID()
    let seedName: String           // Êù•Ëá™ÁßçÂ≠êÁªÑÁöÑÂêçÁß∞
    var files: [URL] = []          // ÊâÄÊúâÁõ∏ÂÖ≥Êñá‰ª∂
    var relationships: [URL: FileRelationship] = [:]  // Êñá‰ª∂ÂÖ≥Á≥ª

    init(seedGroup: LivePhotoSeedGroup) {
        self.seedName = seedGroup.seedName
        self.files = seedGroup.allFiles

        // Ê†áËÆ∞ÁßçÂ≠êÊñá‰ª∂ÁöÑÂÖ≥Á≥ª
        for file in seedGroup.heicFiles {
            relationships[file] = .exactMatch
        }
        for file in seedGroup.movFiles {
            relationships[file] = .exactMatch
        }
    }

    mutating func addContentMatch(_ file: URL) {
        files.append(file)
        relationships[file] = .contentDuplicate
    }

    mutating func addSimilarFile(_ file: URL, similarity: Int) {
        files.append(file)
        relationships[file] = .perceptualSimilar(hammingDistance: similarity)
    }

    func getRelationship(_ file: URL) -> String {
        switch relationships[file] {
        case .exactMatch:
            return "Á≤æÁ°ÆÂåπÈÖç"
        case .contentDuplicate:
            return "ÂÜÖÂÆπÈáçÂ§ç"
        case .perceptualSimilar(let distance):
            return "ËßÜËßâÁõ∏‰ºº (Â∑ÆÂºÇÂ∫¶: \(distance))"
        case nil:
            return "Êú™Áü•ÂÖ≥Á≥ª"
        }
    }
}

/// Êñá‰ª∂ÂÖ≥Á≥ªÁ±ªÂûã
enum FileRelationship {
    case exactMatch                                    // Á≤æÁ°ÆÊñá‰ª∂ÂêçÂåπÈÖç
    case contentDuplicate                             // ÂÜÖÂÆπÂÆåÂÖ®Áõ∏Âêå
    case perceptualSimilar(hammingDistance: Int)      // ËßÜËßâÁõ∏‰ºº
}

/// Ê∏ÖÁêÜËÆ°ÂàíÔºàÈò∂ÊÆµ4ÁöÑÁªìÊûúÔºâ
struct CleaningPlan: Identifiable {
    let id = UUID()
    let groupName: String
    var actions: [URL: CleaningAction] = [:]

    mutating func keepFile(_ file: URL, reason: String) {
        actions[file] = .keep(reason: reason)
    }

    mutating func deleteFile(_ file: URL, reason: String) {
        actions[file] = .delete(reason: reason)
    }

    var filesToKeep: [URL] {
        return actions.compactMap { key, value in
            if case .keep = value { return key }
            return nil
        }
    }

    var filesToDelete: [URL] {
        return actions.compactMap { key, value in
            if case .delete = value { return key }
            return nil
        }
    }
}

/// Ê∏ÖÁêÜÂä®‰Ωú
enum CleaningAction {
    case keep(reason: String)
    case delete(reason: String)
}

// MARK: - pHashÊÑüÁü•ÂìàÂ∏åÁÆóÊ≥ï

/// ËÆ°ÁÆópHashÔºàÊÑüÁü•ÂìàÂ∏åÁÆóÊ≥ïÔºåÊØîdHashÊõ¥ÂáÜÁ°ÆÔºâ
func calculateDHash(for imageURL: URL) throws -> UInt64 {
    #if os(macOS)
    // üöÄ ‰ºòÂåñ0: Ê£ÄÊü•Êñá‰ª∂Â§ßÂ∞èÔºåË∑≥ËøáËøáÂ§ßÁöÑÊñá‰ª∂
    do {
        let fileAttributes = try FileManager.default.attributesOfItem(atPath: imageURL.path)
        if let fileSize = fileAttributes[.size] as? Int64, fileSize > 100 * 1024 * 1024 { // 100MB
            throw HashCalculationError.unknownError("Êñá‰ª∂ËøáÂ§ßÔºåË∑≥ËøáÊÑüÁü•ÂìàÂ∏åËÆ°ÁÆó")
        }
    } catch {
        // Â¶ÇÊûúÊó†Ê≥ïËé∑ÂèñÊñá‰ª∂Â§ßÂ∞èÔºåÁªßÁª≠Â§ÑÁêÜ
    }

    // üöÄ ‰ºòÂåñ1: ‰ΩøÁî®ImageIOÁõ¥Êé•ÂàõÂª∫Áº©Áï•ÂõæÔºåÈÅøÂÖçÂä†ËΩΩÂÖ®Â∞∫ÂØ∏ÂõæÁâá
    guard let imageSource = CGImageSourceCreateWithURL(imageURL as CFURL, nil) else {
        throw HashCalculationError.fileNotReadable(imageURL.path)
    }

    // üöÄ ‰ºòÂåñ2: ÂàõÂª∫Áº©Áï•ÂõæÈÄâÈ°π - pHashÈúÄË¶Å32√ó32ÂÉèÁ¥†‰ª•Ëé∑ÂæóË∂≥Â§üÁöÑÈ¢ëÂüü‰ø°ÊÅØ
    let thumbnailOptions: [CFString: Any] = [
        kCGImageSourceCreateThumbnailFromImageIfAbsent: true,
        kCGImageSourceCreateThumbnailWithTransform: true,
        kCGImageSourceThumbnailMaxPixelSize: 32, // pHashÊé®Ëçê32√ó32ÂÉèÁ¥†
        kCGImageSourceShouldCache: false // ‰∏çÁºìÂ≠òÔºåËäÇÁúÅÂÜÖÂ≠ò
    ]

    guard let thumbnail = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, thumbnailOptions as CFDictionary) else {
        throw HashCalculationError.unknownError("Êó†Ê≥ïÂàõÂª∫Áº©Áï•Âõæ")
    }

    // üöÄ ‰ºòÂåñ3: ‰ΩøÁî®pHashÁÆóÊ≥ïËÆ°ÁÆóÊÑüÁü•ÂìàÂ∏å
    return computePHashFromCGImage(thumbnail)
    #else
    throw HashCalculationError.unknownError("‰∏çÊîØÊåÅÁöÑÂπ≥Âè∞")
    #endif
}

/// ‰ªéCGImageËÆ°ÁÆópHashÔºàÊÑüÁü•ÂìàÂ∏åÔºâ
private func computePHashFromCGImage(_ cgImage: CGImage) -> UInt64 {
    let size = 32 // pHashÊ†áÂáÜÂ∞∫ÂØ∏

    // 1. ËΩ¨Êç¢‰∏∫32√ó32ÁÅ∞Â∫¶ÂõæÂÉè
    var grayPixels: [Double] = Array(repeating: 0, count: size * size)

    let colorSpace = CGColorSpaceCreateDeviceGray()
    let context = CGContext(data: nil,
                           width: size,
                           height: size,
                           bitsPerComponent: 8,
                           bytesPerRow: size,
                           space: colorSpace,
                           bitmapInfo: CGImageAlphaInfo.none.rawValue)

    context?.draw(cgImage, in: CGRect(x: 0, y: 0, width: size, height: size))

    // Ëé∑ÂèñÂÉèÁ¥†Êï∞ÊçÆ
    if let data = context?.data {
        let pixelBuffer = data.bindMemory(to: UInt8.self, capacity: size * size)
        for i in 0..<(size * size) {
            grayPixels[i] = Double(pixelBuffer[i])
        }
    }

    // 2. ËÆ°ÁÆóÁ¶ªÊï£‰ΩôÂº¶ÂèòÊç¢ (DCT)
    let dctData = computeDCT(grayPixels, size: size)

    // 3. ÊèêÂèñ‰ΩéÈ¢ëÂàÜÈáè (8√ó8Â∑¶‰∏äËßíÂå∫ÂüüÔºåÂéªÊéâDCÂàÜÈáè)
    var lowFreq: [Double] = []
    for y in 0..<8 {
        for x in 0..<8 {
            if !(x == 0 && y == 0) { // Ë∑≥ËøáDCÂàÜÈáè
                lowFreq.append(dctData[y * size + x])
            }
    }
    }

    // 4. ËÆ°ÁÆó‰∏≠‰ΩçÊï∞
    let sortedFreq = lowFreq.sorted()
    let median = sortedFreq[sortedFreq.count / 2]

    // 5. ÁîüÊàê64‰ΩçÂìàÂ∏åÂÄº
    var hash: UInt64 = 0
    for i in 0..<min(64, lowFreq.count) {
        if lowFreq[i] > median {
            hash |= (1 << i)
        }
    }

    return hash
}

/// ÁÆÄÂåñÁöÑ2DÁ¶ªÊï£‰ΩôÂº¶ÂèòÊç¢ (DCT)
private func computeDCT(_ data: [Double], size: Int) -> [Double] {
    var result = Array(repeating: 0.0, count: size * size)

    for u in 0..<size {
        for v in 0..<size {
            var sum = 0.0

            for x in 0..<size {
                for y in 0..<size {
                    let pixel = data[y * size + x]
                    let cosU = cos(Double.pi * Double(u) * (Double(x) + 0.5) / Double(size))
                    let cosV = cos(Double.pi * Double(v) * (Double(y) + 0.5) / Double(size))
                    sum += pixel * cosU * cosV
                }
            }

            // Â∫îÁî®DCTÁ≥ªÊï∞
            let cu = u == 0 ? 1.0 / sqrt(2.0) : 1.0
            let cv = v == 0 ? 1.0 / sqrt(2.0) : 1.0

            result[v * size + u] = sum * cu * cv * 2.0 / Double(size)
        }
    }

    return result
}

/// ËÆ°ÁÆóÊ±âÊòéË∑ùÁ¶ª
func hammingDistance(_ hash1: UInt64, _ hash2: UInt64) -> Int {
    let xor = hash1 ^ hash2
    return xor.nonzeroBitCount
}

/// Êñá‰ª∂Â§ßÂ∞èËé∑Âèñ
func getFileSize(_ url: URL) -> Int64 {
    do {
        let resourceValues = try url.resourceValues(forKeys: [.fileSizeKey])
        return Int64(resourceValues.fileSize ?? 0)
    } catch {
        return 0
    }
}

/// Ê£ÄÊü•ÊòØÂê¶‰∏∫ÂõæÁâáÊñá‰ª∂
func isImageFile(_ url: URL) -> Bool {
    let ext = url.pathExtension.lowercased()
    return ["heic", "jpg", "jpeg", "png", "tiff", "bmp"].contains(ext)
}

/// Ê£ÄÊü•ÊòØÂê¶‰∏∫ËßÜÈ¢ëÊñá‰ª∂
func isVideoFile(_ url: URL) -> Bool {
    let ext = url.pathExtension.lowercased()
    return ["mov", "mp4", "m4v", "avi", "mkv"].contains(ext)
}

func calculateHash(for fileURL: URL) throws -> String {
    let chunkSize = 1024 * 1024 // 1MB
    do {
        // Âú®Ê≤ôÁõíÁéØÂ¢É‰∏≠Ôºå‰∏çÈúÄË¶ÅÂØπÂ≠êÊñá‰ª∂Ë∞ÉÁî®startAccessingSecurityScopedResource
        // ÁõÆÂΩïÁ∫ßÂà´ÁöÑÊùÉÈôêÂ∫îËØ•Â∑≤ÁªèË∂≥Â§ü
        print("üî¢ ÂºÄÂßãËÆ°ÁÆóÂìàÂ∏å: \(fileURL.lastPathComponent)")

        // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â≠òÂú®‰∏îÂèØËØª
        guard FileManager.default.isReadableFile(atPath: fileURL.path) else {
            throw HashCalculationError.fileNotReadable(fileURL.path)
        }

        // Ëé∑ÂèñÊñá‰ª∂Â±ûÊÄßÔºåÊ£ÄÊü•Êñá‰ª∂Â§ßÂ∞è
        let fileAttributes = try FileManager.default.attributesOfItem(atPath: fileURL.path)
        guard let fileSize = fileAttributes[.size] as? UInt64, fileSize > 0 else {
            throw HashCalculationError.fileSizeError(fileURL.path)
        }

        let file = try FileHandle(forReadingFrom: fileURL)
        defer {
            do {
                try file.close()
            } catch {
                print("ÂÖ≥Èó≠Êñá‰ª∂Âè•ÊüÑÊó∂Âá∫Èîô: \(error)")
            }
        }

        var hasher = SHA256()

        // If file is small (<= 2MB), hash the whole thing for accuracy.
        if fileSize <= UInt64(chunkSize * 2) {
            try file.seek(toOffset: 0)
            var shouldContinue = true
            while shouldContinue {
                shouldContinue = autoreleasepool {
                    do {
                        let data = try file.read(upToCount: chunkSize) ?? Data()
                        if !data.isEmpty {
                            hasher.update(data: data)
                            return true // Continue
                        } else {
                            return false // End of file
                        }
                    } catch {
                        // ËÆ∞ÂΩïÈîôËØØ‰ΩÜ‰∏çÊäõÂá∫ÔºåËÆ©Â§ñÂ±ÇÂ§ÑÁêÜ
                        print("ËØªÂèñÂ∞èÊñá‰ª∂Êï∞ÊçÆÊó∂Âá∫Èîô \(fileURL.path): \(error.localizedDescription)")
                        return false // Stop on error
                    }
                }
            }
        } else {
            // For larger files, hash only the first and last 1MB.
            // This is a massive performance boost for large video files.

            do {
                // Hash the first 1MB chunk.
                try file.seek(toOffset: 0)
                let headData = try file.read(upToCount: chunkSize) ?? Data()
                if !headData.isEmpty {
                    hasher.update(data: headData)
                }

                // Hash the last 1MB chunk.
                let lastChunkOffset = fileSize > UInt64(chunkSize) ? fileSize - UInt64(chunkSize) : 0
                try file.seek(toOffset: lastChunkOffset)
                let tailData = try file.read(upToCount: chunkSize) ?? Data()
                if !tailData.isEmpty {
                    hasher.update(data: tailData)
                }
            } catch {
                throw HashCalculationError.readError("ËØªÂèñÂ§ßÊñá‰ª∂Êï∞ÊçÆÊó∂Âá∫Èîô \(fileURL.path): \(error.localizedDescription)")
            }
        }

        let digest = hasher.finalize()
        return digest.map { String(format: "%02hhx", $0) }.joined()
    } catch let hashError as HashCalculationError {
        throw hashError
    } catch {
        throw HashCalculationError.unknownError("ËÆ°ÁÆóÂìàÂ∏åÊó∂Âá∫Èîô \(fileURL.path): \(error.localizedDescription)")
    }
}

// MARK: - Core Data Models & Enums

/// Describes the action to be taken on a file and the reason why.
enum FileAction: Hashable {
    case keepAsIs(reason: String)
    case delete(reason: String)
    case userKeep // User override to keep a file that was marked for deletion.
    case userDelete // User override to delete a file that was marked for keeping.

    var isKeep: Bool {
        switch self {
        case .keepAsIs, .userKeep:
            return true
        case .delete, .userDelete:
            return false
        }
    }

    var isUserOverride: Bool {
        switch self {
        case .userKeep, .userDelete:
            return true
        default:
            return false
        }
    }
}

/// A file representation used for display purposes in the UI.
struct DisplayFile: Identifiable, Hashable {
    static func == (lhs: DisplayFile, rhs: DisplayFile) -> Bool {
        lhs.id == rhs.id
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    let id = UUID()
    let url: URL
    let size: Int64
    var action: FileAction

    var fileName: String {
        url.lastPathComponent
    }
}

/// A group of related files (either by hash or by name).
struct FileGroup: Identifiable {
    let id = UUID()
    let groupName: String
    var files: [DisplayFile]
}

/// A structure that holds all data and UI state for a category.
struct CategorizedGroup: Identifiable {
    let id: String // Category name, used for identification
    let categoryName: String
    var groups: [FileGroup]
    var totalSizeToDelete: Int64
    
    // UI state
    var isExpanded: Bool = true
    var displayedGroupCount: Int = 50 // Initial number of groups to show
}

/// Represents a single item in the flattened, displayable list.
enum ResultDisplayItem: Identifiable, Hashable {
    // Hashable conformance
    static func == (lhs: ResultDisplayItem, rhs: ResultDisplayItem) -> Bool { lhs.id == rhs.id }
    func hash(into hasher: inout Hasher) { hasher.combine(id) }

    case categoryHeader(id: String, title: String, groupCount: Int, size: Int64, isExpanded: Bool)
    case fileGroup(FileGroup)
    case loadMore(categoryId: String)

    var id: String {
        switch self {
        case .categoryHeader(let id, _, _, _, _):
            return "header_\(id)"
        case .fileGroup(let group):
            return group.id.uuidString
        case .loadMore(let categoryId):
            return "loadMore_\(categoryId)"
        }
    }
}

/// Represents a single, displayable row in the results list.
enum ResultRow: Identifiable, Hashable {
    case single(DisplayFile)
    case pair(mov: DisplayFile, heic: DisplayFile)

    var id: UUID {
        switch self {
        case .single(let file):
            return file.id
        case .pair(let mov, _):
            return mov.id
        }
    }
}

/// A structure to hold detailed scanning progress information.
struct ScanningProgress {
    let phase: String
    let detail: String
    let progress: Double // Overall progress from 0.0 to 1.0
    let totalFiles: Int
    let processedFiles: Int

    // New detailed parameters
    let estimatedTimeRemaining: TimeInterval?
    let processingSpeedMBps: Double?
    let confidence: ETAConfidence?
}

/// ETAÁΩÆ‰ø°Â∫¶Á≠âÁ∫ß
enum ETAConfidence {
    case low        // ÂàùÂßãÈò∂ÊÆµÔºåÊï∞ÊçÆ‰∏çË∂≥
    case medium     // Êúâ‰∏ÄÂÆöÊï∞ÊçÆÂü∫Á°Ä
    case high       // Êï∞ÊçÆÂÖÖË∂≥ÔºåÈ¢ÑÊµãËæÉÂáÜÁ°Æ
    case veryHigh   // Êé•ËøëÂÆåÊàêÔºåÈ¢ÑÊµãÈùûÂ∏∏ÂáÜÁ°Æ

    var description: String {
        switch self {
        case .low: return "‰º∞ÁÆó‰∏≠"
        case .medium: return "ËÆ°ÁÆó‰∏≠"
        case .high: return "Á∫¶"
        case .veryHigh: return "Âç≥Â∞ÜÂÆåÊàê"
        }
    }
}

/// Êñ∞ÁöÑ4Èò∂ÊÆµÊâ´ÊèèÂÆö‰πâ
enum ScanPhase: String, CaseIterable {
    case fileDiscovery = "Phase 1: File Discovery"
    case exactNameMatching = "Phase 2: Exact Name Matching"
    case contentHashExpansion = "Phase 3: Content Hash Expansion"
    case perceptualSimilarity = "Phase 4: Perceptual Similarity"
    case fileSizeOptimization = "Phase 5: File Size Optimization"

    /// Èò∂ÊÆµÊùÉÈáçÔºàÂç†ÊÄª‰ΩìËøõÂ∫¶ÁöÑÊØî‰æãÔºâ
    var weight: Double {
        switch self {
        case .fileDiscovery: return 0.10
        case .exactNameMatching: return 0.05
        case .contentHashExpansion: return 0.60  // ÂìàÂ∏åËÆ°ÁÆóÊúÄËÄóÊó∂
        case .perceptualSimilarity: return 0.20
        case .fileSizeOptimization: return 0.05
        }
    }

    /// Èò∂ÊÆµËµ∑ÂßãËøõÂ∫¶ÂÄº
    var progressStart: Double {
        let previousWeights = ScanPhase.allCases.prefix(while: { $0 != self }).map { $0.weight }
        return previousWeights.reduce(0, +)
    }

    /// Èò∂ÊÆµÁªìÊùüËøõÂ∫¶ÂÄº
    var progressEnd: Double {
        return progressStart + weight
    }
}

/// Áªü‰∏ÄÁöÑÊâ´ÊèèËøõÂ∫¶ÁÆ°ÁêÜÂô®
class ScanProgressManager {
    private var etaCalculator = ETACalculator()
    private var currentPhase: ScanPhase?
    private var overallStartTime: Date?
    private var phaseStartTime: Date?
    private var phaseTotalWork: Int = 0

    /// ÂºÄÂßãÊï¥‰∏™Êâ´ÊèèËøáÁ®ã
    func startScanning() {
        overallStartTime = Date()
        etaCalculator = ETACalculator() // ÈáçÁΩÆETAËÆ°ÁÆóÂô®
    }

    /// ÂºÄÂßãÊñ∞Èò∂ÊÆµ
    func startPhase(_ phase: ScanPhase, totalWork: Int) {
        currentPhase = phase
        phaseTotalWork = totalWork
        phaseStartTime = Date()
        etaCalculator.startPhase(phase.rawValue, totalWork: totalWork, weight: phase.weight)
    }

    /// Êõ¥Êñ∞ÂΩìÂâçÈò∂ÊÆµËøõÂ∫¶
    func updateProgress(completed: Int, detail: String, totalFiles: Int) -> ScanningProgress {
        guard let phase = currentPhase else {
            return ScanningProgress(
                phase: "Unknown",
                detail: detail,
                progress: 0.0,
                totalFiles: totalFiles,
                processedFiles: completed,
                estimatedTimeRemaining: nil,
                processingSpeedMBps: nil,
                confidence: .low
            )
        }

        let (eta, confidence) = etaCalculator.updateProgress(phase: phase.rawValue, completed: completed)

        // ËÆ°ÁÆóËØ•Èò∂ÊÆµÂÜÖÁöÑËøõÂ∫¶ÊØî‰æãÔºàÈò≤Ê≠¢Èô§Èõ∂Ôºâ
        let phaseProgress = phaseTotalWork > 0 ? Double(completed) / Double(phaseTotalWork) : 0.0

        // ËÆ°ÁÆóÊÄª‰ΩìËøõÂ∫¶
        let overallProgress = phase.progressStart + (min(1.0, phaseProgress) * phase.weight)

        return ScanningProgress(
            phase: phase.rawValue,
            detail: detail,
            progress: min(1.0, overallProgress),
            totalFiles: totalFiles,
            processedFiles: completed,
            estimatedTimeRemaining: eta,
            processingSpeedMBps: nil, // ÂèØ‰ª•ÂêéÁª≠Ê∑ªÂä†
            confidence: confidence
        )
    }

    /// Êõ¥Êñ∞Èò∂ÊÆµÊÄªÂ∑•‰ΩúÈáèÔºàÂä®ÊÄÅË∞ÉÊï¥Ôºâ
    func updateTotalWork(_ newTotal: Int) {
        phaseTotalWork = max(phaseTotalWork, newTotal)
    }

    /// ÂÆåÊàêÂΩìÂâçÈò∂ÊÆµ
    func completePhase() -> ScanningProgress? {
        guard let phase = currentPhase else { return nil }

        let progress = ScanningProgress(
            phase: "\(phase.rawValue) - Completed",
            detail: "Phase completed",
            progress: phase.progressEnd,
            totalFiles: 0,
            processedFiles: 0,
            estimatedTimeRemaining: nil,
            processingSpeedMBps: nil,
            confidence: .veryHigh
        )

        return progress
    }

    /// Ëé∑ÂèñÊÄª‰ΩìËøõÂ∫¶‰ø°ÊÅØ
    func getOverallProgress() -> (elapsed: TimeInterval, phase: String?) {
        let elapsed = overallStartTime?.timeIntervalSinceNow ?? 0
        return (elapsed: -elapsed, phase: currentPhase?.rawValue)
    }
}

/// Êô∫ËÉΩETAËÆ°ÁÆóÂô®
class ETACalculator {
    private struct PhaseData {
        let startTime: Date
        let totalWork: Int
        let completedWork: Int
        var workHistory: [(timestamp: Date, completed: Int, processingTime: TimeInterval)] = []
        let phaseWeight: Double // ËØ•Èò∂ÊÆµÂç†ÊÄª‰ΩìËøõÂ∫¶ÁöÑÊùÉÈáç
    }

    private var phases: [String: PhaseData] = [:]
    private var overallStartTime: Date?
    private let smoothingWindow = 10 // ÁßªÂä®Âπ≥ÂùáÁ™óÂè£Â§ßÂ∞è

    /// ÂºÄÂßãÊñ∞Èò∂ÊÆµ
    func startPhase(_ phaseName: String, totalWork: Int, weight: Double) {
        if overallStartTime == nil {
            overallStartTime = Date()
        }

        phases[phaseName] = PhaseData(
            startTime: Date(),
            totalWork: totalWork,
            completedWork: 0,
            phaseWeight: weight
        )
    }

    /// Êõ¥Êñ∞Èò∂ÊÆµËøõÂ∫¶Âπ∂ËÆ°ÁÆóETA
    func updateProgress(phase: String, completed: Int) -> (eta: TimeInterval?, confidence: ETAConfidence) {
        guard var phaseData = phases[phase] else {
            return (nil, .low)
        }

        let now = Date()
        let processingTime = now.timeIntervalSince(phaseData.startTime)

        // ËÆ∞ÂΩïÂéÜÂè≤Êï∞ÊçÆ
        phaseData.workHistory.append((
            timestamp: now,
            completed: completed,
            processingTime: processingTime
        ))

        // ‰øùÊåÅÁßªÂä®Á™óÂè£Â§ßÂ∞è
        if phaseData.workHistory.count > smoothingWindow {
            phaseData.workHistory.removeFirst()
        }

        phaseData = PhaseData(
            startTime: phaseData.startTime,
            totalWork: phaseData.totalWork,
            completedWork: completed,
            workHistory: phaseData.workHistory,
            phaseWeight: phaseData.phaseWeight
        )
        phases[phase] = phaseData

        return calculateSmartETA(for: phase, phaseData: phaseData)
    }

    /// Êô∫ËÉΩETAËÆ°ÁÆó
    private func calculateSmartETA(for phase: String, phaseData: PhaseData) -> (eta: TimeInterval?, confidence: ETAConfidence) {
        guard phaseData.completedWork > 0 && phaseData.totalWork > phaseData.completedWork else {
            return (nil, .low)
        }

        let historyCount = phaseData.workHistory.count
        var confidence: ETAConfidence = .low

        // Ê†πÊçÆÂéÜÂè≤Êï∞ÊçÆÈáèÁ°ÆÂÆöÁΩÆ‰ø°Â∫¶
        if historyCount >= 20 {
            confidence = .veryHigh
        } else if historyCount >= 10 {
            confidence = .high
        } else if historyCount >= 5 {
            confidence = .medium
        }

        // ‰ΩøÁî®Â§öÁßçÁÆóÊ≥ïËÆ°ÁÆóETAÔºåÁÑ∂ÂêéÂä†ÊùÉÂπ≥Âùá
        var estimates: [TimeInterval] = []

        // 1. ÁÆÄÂçïÁ∫øÊÄßÈ¢ÑÊµã
        let linearETA = calculateLinearETA(phaseData: phaseData)
        estimates.append(linearETA)

        // 2. ÁßªÂä®Âπ≥ÂùáÈÄüÂ∫¶È¢ÑÊµã
        if let movingAvgETA = calculateMovingAverageETA(phaseData: phaseData) {
            estimates.append(movingAvgETA)
        }

        // 3. ÊåáÊï∞Ë°∞ÂáèÈ¢ÑÊµãÔºàÁªôËøëÊúüÊï∞ÊçÆÊõ¥È´òÊùÉÈáçÔºâ
        if let exponentialETA = calculateExponentialETA(phaseData: phaseData) {
            estimates.append(exponentialETA)
        }

        // Ê≥®ÊÑèÔºöÊñá‰ª∂Â§ßÂ∞èÂä†ÊùÉÈ¢ÑÊµãÊöÇÊú™ÂÆûÁé∞

        // Âä†ÊùÉÂπ≥ÂùáÂ§ö‰∏™È¢ÑÊµãÁªìÊûú
        let weightedETA = calculateWeightedAverage(estimates: estimates, confidence: confidence)

        // Â∫îÁî®ËæπÁïåÊ£ÄÊü•ÂíåÂπ≥ÊªëÂ§ÑÁêÜ
        let smoothedETA = applySmoothingAndBounds(eta: weightedETA, phaseData: phaseData)

        return (smoothedETA, confidence)
    }

    // MARK: - ÂêÑÁßçETAÁÆóÊ≥ïÂÆûÁé∞

    private func calculateLinearETA(phaseData: PhaseData) -> TimeInterval {
        let elapsed = Date().timeIntervalSince(phaseData.startTime)
        let progress = Double(phaseData.completedWork) / Double(phaseData.totalWork)
        let estimatedTotal = elapsed / progress
        return max(0, estimatedTotal - elapsed)
    }

    private func calculateMovingAverageETA(phaseData: PhaseData) -> TimeInterval? {
        guard phaseData.workHistory.count >= 2 else { return nil }

        let recent = Array(phaseData.workHistory.suffix(min(5, phaseData.workHistory.count)))
        var speeds: [Double] = []

        // ÂÆâÂÖ®ÈÅçÂéÜÔºåÈÅøÂÖçÊï∞ÁªÑË∂äÁïå
        for i in 1..<recent.count {
            guard i < recent.count && i-1 >= 0 && i-1 < recent.count else {
                print("‚ö†Ô∏è ETAËÆ°ÁÆó‰∏≠Êï∞ÁªÑËÆøÈóÆË∂äÁïåÔºåË∑≥ËøáÁ¥¢Âºï \(i)")
                continue
            }
            let timeDiff = recent[i].timestamp.timeIntervalSince(recent[i-1].timestamp)
            let workDiff = recent[i].completed - recent[i-1].completed
            if timeDiff > 0 && workDiff > 0 {
                speeds.append(Double(workDiff) / timeDiff)
            }
        }

        guard !speeds.isEmpty else { return nil }

        let avgSpeed = speeds.reduce(0, +) / Double(speeds.count)
        let remainingWork = phaseData.totalWork - phaseData.completedWork
        return Double(remainingWork) / avgSpeed
    }

    private func calculateExponentialETA(phaseData: PhaseData) -> TimeInterval? {
        guard phaseData.workHistory.count >= 3 else { return nil }

        var weightedSpeed: Double = 0
        var totalWeight: Double = 0
        let history = phaseData.workHistory

        // ÂÆâÂÖ®ÈÅçÂéÜÔºåÈÅøÂÖçÊï∞ÁªÑË∂äÁïå
        for i in 1..<history.count {
            guard i < history.count && i-1 >= 0 && i-1 < history.count else {
                print("‚ö†Ô∏è ÊåáÊï∞ETAËÆ°ÁÆó‰∏≠Êï∞ÁªÑËÆøÈóÆË∂äÁïåÔºåË∑≥ËøáÁ¥¢Âºï \(i)")
                continue
            }
            let timeDiff = history[i].timestamp.timeIntervalSince(history[i-1].timestamp)
            let workDiff = history[i].completed - history[i-1].completed

            if timeDiff > 0 && workDiff > 0 {
                let speed = Double(workDiff) / timeDiff
                let weight = pow(0.8, Double(history.count - i)) // ÊåáÊï∞Ë°∞ÂáèÊùÉÈáç

                weightedSpeed += speed * weight
                totalWeight += weight
            }
        }

        guard totalWeight > 0 else { return nil }

        let avgSpeed = weightedSpeed / totalWeight
        let remainingWork = phaseData.totalWork - phaseData.completedWork
        return Double(remainingWork) / avgSpeed
    }


    private func calculateWeightedAverage(estimates: [TimeInterval], confidence: ETAConfidence) -> TimeInterval {
        guard !estimates.isEmpty else { return 0 }

        // Ê†πÊçÆÁΩÆ‰ø°Â∫¶Ë∞ÉÊï¥ÁÆóÊ≥ïÊùÉÈáç
        let weights: [Double]
        switch confidence {
        case .low:
            weights = [0.6, 0.4] // ÂÅèÂêëÁÆÄÂçïÁÆóÊ≥ï
        case .medium:
            weights = [0.4, 0.4, 0.2] // Âπ≥Ë°°
        case .high:
            weights = [0.2, 0.3, 0.5] // ÂÅèÂêëÂ§çÊùÇÁÆóÊ≥ï
        case .veryHigh:
            weights = [0.1, 0.2, 0.7] // ‰∏ªË¶Å‰æùÈù†ÊåáÊï∞Ë°∞Âáè
        }

        var weightedSum: Double = 0
        var totalWeight: Double = 0

        for (i, estimate) in estimates.enumerated() {
            let weight = i < weights.count ? weights[i] : 0.1
            weightedSum += estimate * weight
            totalWeight += weight
        }

        return totalWeight > 0 ? weightedSum / totalWeight : estimates.first ?? 0
    }

    private func applySmoothingAndBounds(eta: TimeInterval, phaseData: PhaseData) -> TimeInterval {
        let minETA: TimeInterval = 1 // ÊúÄÂ∞ë1Áßí
        let maxETA: TimeInterval = 3600 // ÊúÄÂ§ö1Â∞èÊó∂

        var smoothedETA = max(minETA, min(maxETA, eta))

        // Â¶ÇÊûúÊé•ËøëÂÆåÊàêÔºåËøõ‰∏ÄÊ≠•ÈôêÂà∂ETA
        let progress = Double(phaseData.completedWork) / Double(phaseData.totalWork)
        if progress > 0.95 {
            smoothedETA = min(smoothedETA, 30) // Êé•ËøëÂÆåÊàêÊó∂ÊúÄÂ§ö30Áßí
        } else if progress > 0.90 {
            smoothedETA = min(smoothedETA, 60) // 90%ÂÆåÊàêÊó∂ÊúÄÂ§ö1ÂàÜÈíü
        }

        return smoothedETA
    }
}

/// The different states the main view can be in.
enum ViewState {
    case welcome
    case scanning(progress: ScanningProgress, animationRate: Double)
    case results
    case error(String)
}

/// ÈîôËØØÊÅ¢Â§çÈÄâÈ°π
enum ErrorRecoveryOption {
    case retry(title: String, action: () async -> Void)
    case skip(title: String, action: () async -> Void)
    case abort(title: String, action: () async -> Void)
    case continueWithoutFile(title: String, action: () async -> Void)
}

/// ËØ¶ÁªÜÁöÑÈîôËØØ‰ø°ÊÅØÁªìÊûÑ
struct DetailedError {
    let title: String
    let message: String
    let technicalDetails: String?
    let recoveryOptions: [ErrorRecoveryOption]
    let canContinue: Bool

    init(title: String, message: String, technicalDetails: String? = nil, recoveryOptions: [ErrorRecoveryOption] = [], canContinue: Bool = false) {
        self.title = title
        self.message = message
        self.technicalDetails = technicalDetails
        self.recoveryOptions = recoveryOptions
        self.canContinue = canContinue
    }
}

/// ÈîôËØØ‰∏ä‰∏ãÊñáÔºåÁî®‰∫éÂú®ÈîôËØØÊÅ¢Â§çÊó∂‰øùÂ≠òÂøÖË¶ÅÁöÑÁä∂ÊÄÅ‰ø°ÊÅØ
struct ErrorContext {
    let fileURL: URL?
    let currentPhase: String
    let totalFiles: Int
    let processedFiles: Int
    let canSkipFile: Bool
    let resumeOperation: (() async -> Void)?
}

// A typealias for a list of metadata items, making the data model flexible.
typealias FileMetadata = [(label: String, value: String, icon: String)]

extension FileAction {
    var reasonText: String {
        switch self {
        case .keepAsIs(let reason):
            return reason
        case .delete(let reason):
            return reason
        case .userKeep:
            return "Forced Keep by User"
        case .userDelete:
            return "Forced Deletion by User"
        }
    }
} 