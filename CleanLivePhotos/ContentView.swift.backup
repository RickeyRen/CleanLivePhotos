import SwiftUI
import AVFoundation
import ImageIO
#if os(macOS)
import AppKit
import UniformTypeIdentifiers
#endif

// MARK: - Main Content View

struct ContentView: View {
    @State private var state: ViewState = .welcome
    @State private var currentScanTask: Task<Void, Error>?
    @State private var isCancelRequested = false
    @State private var showAlert: Bool = false
    @State private var alertTitle: String = ""
    @State private var alertMessage: String = ""

    // é”™è¯¯å¤„ç†çŠ¶æ€
    @State private var showErrorDialog: Bool = false
    @State private var currentError: DetailedError?
    @State private var errorContext: ErrorContext?

    // ç»Ÿä¸€çš„æ‰«æè¿›åº¦ç®¡ç†å™¨
    @State private var progressManager = ScanProgressManager()
    @State private var folderAccessManager = FolderAccessManager()
    @State private var selectedFile: DisplayFile?
    @State private var scannedFolderPath: String?

    // State for results display
    @State private var allResultGroups: [FileGroup] = [] // Source of truth for all files
    @State private var masterCategorizedGroups: [CategorizedGroup] = [] // Source of truth for categories
    @State private var displayItems: [ResultDisplayItem] = [] // Flattened list for the View
    private let categoryPageSize = 50 // How many items to load at a time within a category
    
    // Store original actions to allow "Automatic" state to be restored.
    @State private var originalFileActions: [UUID: FileAction] = [:]
    

    var body: some View {
        contentView
            .alert(alertTitle, isPresented: $showAlert) {
                Button("OK", role: .cancel) { }
            } message: {
                Text(alertMessage)
            }
            .sheet(isPresented: $showErrorDialog) {
                if let error = currentError {
                    ErrorRecoveryView(
                        error: error,
                        context: errorContext,
                        onDismiss: { showErrorDialog = false }
                    )
                }
            }
            .preferredColorScheme(.dark)
    }

    @ViewBuilder
    private var contentView: some View {
        ZStack {
            #if os(macOS)
            WindowAccessor()
            #endif

            switch state {
            case .welcome:
                WelcomeView(onScan: { handleScanRequest() })
                
            case .scanning(let progress, let animationRate):
                ScanningView(progressState: progress, animationRate: animationRate)
                
            case .results:
                VStack(spacing: 0) {
                    if displayItems.isEmpty {
                        NoResultsView(onStartOver: resetToWelcomeState)
                    } else {
                        HStack(spacing: 0) {
                            ResultsView(
                                items: displayItems,
                                selectedFile: $selectedFile,
                                onUpdateUserAction: updateUserAction,
                                onToggleCategory: toggleCategory,
                                onLoadMoreInCategory: loadMoreInCategory
                            )
                            Divider()
                                .background(.regularMaterial)
                            PreviewPane(file: selectedFile)
                                .frame(maxWidth: .infinity)
                        }
                    }
                    
                    if !allResultGroups.isEmpty {
                        FooterView(
                            groups: allResultGroups,
                            scannedPath: scannedFolderPath,
                            onDelete: { executeCleaningPlan(for: allResultGroups) },
                            onGoHome: resetToWelcomeState
                        )
                    }
                }
            case .error(let errorMessage):
                ErrorView(
                    message: errorMessage,
                    onDismiss: { self.state = .welcome }
                )
                .padding(.top, 44)
            }
            
            if case .scanning = state, currentScanTask != nil {
                VStack {
                    HStack {
                        Spacer()
                        CloseButton {
                            isCancelRequested = true
                            currentScanTask?.cancel()
                            state = .welcome
                        }
                    }
                    Spacer()
                }
            } else if case .results = state {
                // This close button is being removed as per user request.
                // The functionality will be moved to a new button in the FooterView.
            }
        }
        .frame(minWidth: 900, maxWidth: .infinity, minHeight: 600, maxHeight: .infinity)
        .background(.regularMaterial)
        .ignoresSafeArea(.all)
    }
    
    private func handleScanRequest() {
        #if os(macOS)
        let panel = NSOpenPanel()
        panel.canChooseFiles = false
        panel.canChooseDirectories = true
        panel.allowsMultipleSelection = false

        if panel.runModal() == .OK, let url = panel.url {
            isCancelRequested = false // é‡ç½®å–æ¶ˆæ ‡è®°
            currentScanTask = Task {
                if await folderAccessManager.requestAccess(to: url) {
                    // ä¿å­˜æ‰«æè·¯å¾„ç”¨äºè°ƒè¯•ä¿¡æ¯
                    await MainActor.run {
                        scannedFolderPath = url.path
                    }
                    // Reset state before starting a new scan.
                    // Start accessing the security-scoped resource before scanning.
                    guard await folderAccessManager.startAccessing() else {
                        await MainActor.run {
                            let detailedError = "Failed to start access to the folder. This might be a permissions issue. Please try selecting the folder again."
                            self.state = .error(detailedError)
                        }
                        return
                    }
                    // Ensure we stop accessing the resource when the scan is complete or fails.
                    defer { folderAccessManager.stopAccessing() }
                    
                    do {
                        try await perfectScan(in: url)
                    } catch is CancellationError {
                        // This is expected when the user cancels, just reset the state.
                        await MainActor.run {
                            self.state = .welcome
                        }
                    } catch {
                        await MainActor.run {
                            let detailedError = """
                            An unexpected error occurred during the scan.

                            Details:
                            \(error.localizedDescription)

                            ---
                            Technical Info:
                            \(String(describing: error))
                            """
                            self.state = .error(detailedError)
                        }
                    }
                } else {
                    await MainActor.run {
                        self.state = .error("Failed to gain permission to access the folder. Please select the folder and grant permission when prompted.")
                    }
                }
            }
        }
        #endif
    }
    
    private func executeCleaningPlan(for groups: [FileGroup]) {
        Task {
            // Start accessing the security-scoped resource.
            guard await folderAccessManager.startAccessing() else {
                await MainActor.run {
                    self.alertTitle = "Permission Error"
                    self.alertMessage = "Could not access the folder to execute the plan. Please try scanning the folder again."
                    self.showAlert = true
                }
                return
            }
            // Defer stopping access to ensure it's called even if errors occur.
            defer { folderAccessManager.stopAccessing() }

            let allFiles = groups.flatMap { $0.files }
            
            // --- Step 1: Perform Deletions ---
            var deletionSuccessCount = 0
            var deletionFailCount = 0
            let filesToDelete = allFiles.filter { if case .delete = $0.action { return true } else { return false } }
            
            for file in filesToDelete {
                do {
                    try FileManager.default.removeItem(at: file.url)
                    deletionSuccessCount += 1
                } catch {
                    print("Error deleting file \(file.fileName): \(error)")
                    deletionFailCount += 1
                }
            }
            

            await MainActor.run {
                self.alertTitle = "Cleaning Complete"
                var message = "\(deletionSuccessCount) files were successfully deleted."
                if deletionFailCount > 0 { message += "\n\(deletionFailCount) files could not be deleted." }

                self.alertMessage = message
                self.showAlert = true
                self.state = .welcome // Reset view after cleaning
            }
        }
    }
    
    // MARK: - The "Perfect Scan" Engine
    
    /// æ–°çš„4é˜¶æ®µæ‰«æç®—æ³•å®ç°
    private func perfectScan(in directoryURL: URL) async throws {
        progressManager.startScanning()

        // === é˜¶æ®µ1: æ–‡ä»¶å‘ç° ===
        let allMediaFiles = try await stage1_FileDiscovery(in: directoryURL)
        print("ğŸ“ é˜¶æ®µ1å®Œæˆ: å‘ç° \(allMediaFiles.count) ä¸ªåª’ä½“æ–‡ä»¶")

        // === é˜¶æ®µ2: ç²¾ç¡®æ–‡ä»¶ååŒ¹é… ===
        let seedGroups = try await stage2_ExactNameMatching(files: allMediaFiles)
        print("ğŸ“ é˜¶æ®µ2å®Œæˆ: å‘ç° \(seedGroups.count) ä¸ªLive Photoç§å­ç»„")

        // === é˜¶æ®µ3: å†…å®¹å“ˆå¸Œæ‰©å±• ===
        let contentGroups = try await stage3_ContentHashExpansion(seedGroups: seedGroups, allFiles: allMediaFiles)
        print("ğŸ”— é˜¶æ®µ3å®Œæˆ: æ‰©å±•ä¸º \(contentGroups.count) ä¸ªå†…å®¹ç»„")

        // === é˜¶æ®µ4: æ„ŸçŸ¥å“ˆå¸Œç›¸ä¼¼æ€§ ===
        let expandedGroups = try await stage4_PerceptualSimilarity(contentGroups: contentGroups, allFiles: allMediaFiles)
        print("ğŸ‘ï¸ é˜¶æ®µ4å®Œæˆ: æ„ŸçŸ¥ç›¸ä¼¼æ€§æ£€æµ‹å®Œæˆ")

        // === é˜¶æ®µ5: æ–‡ä»¶å¤§å°ä¼˜é€‰ ===
        let cleaningPlans = try await stage5_FileSizeOptimization(contentGroups: expandedGroups)
        print("âš–ï¸ é˜¶æ®µ5å®Œæˆ: ç”Ÿæˆ \(cleaningPlans.count) ä¸ªæ¸…ç†è®¡åˆ’")

        // è½¬æ¢ä¸ºç°æœ‰çš„UIæ•°æ®ç»“æ„
        let finalResults = convertToDisplayFormat(cleaningPlans: cleaningPlans)

        await MainActor.run {
            self.showResults(groups: finalResults.fileGroups, categorizedGroups: finalResults.categorizedGroups)
        }
    }

    // MARK: - é˜¶æ®µ1: æ–‡ä»¶å‘ç°
    private func stage1_FileDiscovery(in directoryURL: URL) async throws -> [URL] {
        startPhase(.fileDiscovery, totalWork: 1000) // ä¼°ç®—å€¼

        var allMediaFiles: [URL] = []
        let resourceKeys: [URLResourceKey] = [.isRegularFileKey, .isDirectoryKey, .typeIdentifierKey]
        let options: FileManager.DirectoryEnumerationOptions = [.skipsHiddenFiles, .skipsPackageDescendants]

        guard let sequence = URLDirectoryAsyncSequence(url: directoryURL, options: options, resourceKeys: resourceKeys) else {
            throw NSError(domain: "ScanError", code: 1, userInfo: [NSLocalizedDescriptionKey: "æ— æ³•åˆ›å»ºæ–‡ä»¶æšä¸¾å™¨"])
        }

        var discoveredCount = 0

        for await fileURL in sequence {
            if Task.isCancelled { throw CancellationError() }

            guard let typeIdentifier = try? fileURL.resourceValues(forKeys: [.typeIdentifierKey]).typeIdentifier,
                  let fileType = UTType(typeIdentifier),
                  (fileType.conforms(to: .image) || fileType.conforms(to: .movie)) else {
                continue
            }

            allMediaFiles.append(fileURL)
            discoveredCount += 1

            if discoveredCount % 50 == 0 {
                await updateProgress(
                    completed: discoveredCount,
                    detail: "å·²å‘ç° \(discoveredCount) ä¸ªåª’ä½“æ–‡ä»¶...",
                    totalFiles: discoveredCount * 2
                )
            }
        }

        await updateProgress(
            completed: discoveredCount,
            detail: "æ–‡ä»¶å‘ç°å®Œæˆï¼Œå…±å‘ç° \(discoveredCount) ä¸ªåª’ä½“æ–‡ä»¶",
            totalFiles: discoveredCount
        )

        return allMediaFiles
    }

    // MARK: - é˜¶æ®µ2: ç²¾ç¡®æ–‡ä»¶ååŒ¹é…
    private func stage2_ExactNameMatching(files: [URL]) async throws -> [LivePhotoSeedGroup] {
        startPhase(.exactNameMatching, totalWork: files.count)

        var groups: [String: LivePhotoSeedGroup] = [:]

        for (index, url) in files.enumerated() {
            if Task.isCancelled { throw CancellationError() }

            let baseName = url.deletingPathExtension().lastPathComponent // ä¸åšä»»ä½•å¤„ç†
            let ext = url.pathExtension.lowercased()

            if ext == "heic" || ext == "mov" {
                if groups[baseName] == nil {
                    groups[baseName] = LivePhotoSeedGroup(seedName: baseName)
                }

                if ext == "heic" {
                    groups[baseName]!.heicFiles.append(url)
                } else {
                    groups[baseName]!.movFiles.append(url)
                }
            }

            if index % 100 == 0 {
                await updateProgress(
                    completed: index + 1,
                    detail: "æ­£åœ¨åŒ¹é…æ–‡ä»¶å (\(index + 1)/\(files.count))...",
                    totalFiles: files.count
                )
            }
        }

        // åªä¿ç•™çœŸæ­£çš„Live Photoé…å¯¹
        let seedGroups = groups.values.filter { $0.hasCompletePair }

        await updateProgress(
            completed: files.count,
            detail: "ç²¾ç¡®åŒ¹é…å®Œæˆï¼Œå‘ç° \(seedGroups.count) ä¸ªLive Photoç»„",
            totalFiles: files.count
        )

        return Array(seedGroups)
    }

    // MARK: - é˜¶æ®µ3: å†…å®¹å“ˆå¸Œæ‰©å±•
    private func stage3_ContentHashExpansion(seedGroups: [LivePhotoSeedGroup], allFiles: [URL]) async throws -> [ContentGroup] {
        startPhase(.contentHashExpansion, totalWork: allFiles.count)

        var contentGroups: [ContentGroup] = []
        var processedFiles: Set<URL> = []

        // å¤„ç†æ¯ä¸ªç§å­ç»„
        for (groupIndex, seedGroup) in seedGroups.enumerated() {
            var contentGroup = ContentGroup(seedGroup: seedGroup)

            // è®¡ç®—ç§å­ç»„æ‰€æœ‰æ–‡ä»¶çš„å“ˆå¸Œ
            var seedHashes: Set<String> = []
            for file in seedGroup.allFiles {
                do {
                    let hash = try calculateHash(for: file)
                    seedHashes.insert(hash)
                    processedFiles.insert(file)
                } catch {
                    print("âš ï¸ è®¡ç®—ç§å­æ–‡ä»¶å“ˆå¸Œå¤±è´¥: \(file.lastPathComponent) - \(error)")
                    processedFiles.insert(file) // ä»ç„¶æ ‡è®°ä¸ºå·²å¤„ç†
                }
            }

            // æ‰«æå‰©ä½™æ–‡ä»¶ï¼ŒæŸ¥æ‰¾ç›¸åŒå“ˆå¸Œ
            for file in allFiles where !processedFiles.contains(file) {
                do {
                    let fileHash = try calculateHash(for: file)
                    if seedHashes.contains(fileHash) {
                        contentGroup.addContentMatch(file)
                        processedFiles.insert(file)
                    }
                } catch {
                    print("âš ï¸ è®¡ç®—æ–‡ä»¶å“ˆå¸Œå¤±è´¥: \(file.lastPathComponent) - \(error)")
                }
            }

            contentGroups.append(contentGroup)

            await updateProgress(
                completed: processedFiles.count,
                detail: "æ­£åœ¨æ‰©å±•å†…å®¹ç»„ \(groupIndex + 1)/\(seedGroups.count)...",
                totalFiles: allFiles.count
            )
        }

        await updateProgress(
            completed: allFiles.count,
            detail: "å†…å®¹å“ˆå¸Œæ‰©å±•å®Œæˆ",
            totalFiles: allFiles.count
        )

        return contentGroups
    }

    // MARK: - é˜¶æ®µ4: æ„ŸçŸ¥å“ˆå¸Œç›¸ä¼¼æ€§
    private func stage4_PerceptualSimilarity(contentGroups: [ContentGroup], allFiles: [URL]) async throws -> [ContentGroup] {
        startPhase(.perceptualSimilarity, totalWork: contentGroups.count * 50) // ä¼°ç®—å·¥ä½œé‡

        var processedFiles: Set<URL> = []
        let SIMILARITY_THRESHOLD = 8 // dHashæ±‰æ˜è·ç¦»é˜ˆå€¼ï¼ˆçº¦85%ç›¸ä¼¼ï¼‰

        // æ”¶é›†å·²å¤„ç†çš„æ–‡ä»¶
        for group in contentGroups {
            processedFiles.formUnion(group.files)
        }

        var workCompleted = 0

        for (groupIndex, group) in contentGroups.enumerated() {
            let imageFiles = group.files.filter { isImageFile($0) }

            for seedImage in imageFiles {
                do {
                    let seedPHash = try calculateDHash(for: seedImage)

                    // æŸ¥æ‰¾ç›¸ä¼¼å›¾ç‰‡
                    for remainingFile in allFiles where !processedFiles.contains(remainingFile) && isImageFile(remainingFile) {
                        do {
                            let filePHash = try calculateDHash(for: remainingFile)
                            let similarity = hammingDistance(seedPHash, filePHash)

                            if similarity <= SIMILARITY_THRESHOLD {
                                group.addSimilarFile(remainingFile, similarity: similarity)
                                processedFiles.insert(remainingFile)
                                print("ğŸ¯ å‘ç°ç›¸ä¼¼å›¾ç‰‡: \(remainingFile.lastPathComponent) (å·®å¼‚åº¦: \(similarity))")
                            }
                        } catch {
                            print("âš ï¸ è®¡ç®—æ„ŸçŸ¥å“ˆå¸Œå¤±è´¥: \(remainingFile.lastPathComponent) - \(error)")
                        }
                    }
                } catch {
                    print("âš ï¸ è®¡ç®—ç§å­å›¾ç‰‡æ„ŸçŸ¥å“ˆå¸Œå¤±è´¥: \(seedImage.lastPathComponent) - \(error)")
                }

                workCompleted += 1
                if workCompleted % 10 == 0 {
                    await updateProgress(
                        completed: workCompleted,
                        detail: "æ­£åœ¨æ£€æµ‹ç›¸ä¼¼æ€§ (ç»„ \(groupIndex + 1)/\(contentGroups.count))...",
                        totalFiles: contentGroups.count * imageFiles.count
                    )
                }
            }
        }

        await updateProgress(
            completed: workCompleted,
            detail: "æ„ŸçŸ¥ç›¸ä¼¼æ€§æ£€æµ‹å®Œæˆ",
            totalFiles: workCompleted
        )

        return contentGroups
    }

    // MARK: - é˜¶æ®µ5: æ–‡ä»¶å¤§å°ä¼˜é€‰
    private func stage5_FileSizeOptimization(contentGroups: [ContentGroup]) async throws -> [CleaningPlan] {
        startPhase(.fileSizeOptimization, totalWork: contentGroups.count)

        var plans: [CleaningPlan] = []

        for (index, group) in contentGroups.enumerated() {
            if Task.isCancelled { throw CancellationError() }

            let heicFiles = group.files.filter { $0.pathExtension.lowercased() == "heic" }
            let movFiles = group.files.filter { $0.pathExtension.lowercased() == "mov" }

            // é€‰æ‹©æœ€å¤§çš„HEICå’ŒMOVæ–‡ä»¶
            let bestHEIC = heicFiles.max { getFileSize($0) < getFileSize($1) }
            let bestMOV = movFiles.max { getFileSize($0) < getFileSize($1) }

            var plan = CleaningPlan(groupName: group.seedName)

            // æ ‡è®°ä¿ç•™æœ€ä½³é…å¯¹
            if let bestHEIC = bestHEIC {
                let sizeStr = ByteCountFormatter.string(fromByteCount: getFileSize(bestHEIC), countStyle: .file)
                plan.keepFile(bestHEIC, reason: "æœ€å¤§HEICæ–‡ä»¶ (\(sizeStr))")
            }
            if let bestMOV = bestMOV {
                let sizeStr = ByteCountFormatter.string(fromByteCount: getFileSize(bestMOV), countStyle: .file)
                plan.keepFile(bestMOV, reason: "æœ€å¤§MOVæ–‡ä»¶ (\(sizeStr))")
            }

            // æ ‡è®°åˆ é™¤å…¶ä»–æ–‡ä»¶
            for file in group.files {
                if file != bestHEIC && file != bestMOV {
                    let reason = group.getRelationship(file)
                    plan.deleteFile(file, reason: reason)
                }
            }

            plans.append(plan)

            await updateProgress(
                completed: index + 1,
                detail: "æ­£åœ¨ä¼˜é€‰æ–‡ä»¶ (\(index + 1)/\(contentGroups.count))...",
                totalFiles: contentGroups.count
            )
        }

        return plans
    }

    // MARK: - ç»“æœè½¬æ¢
    private func convertToDisplayFormat(cleaningPlans: [CleaningPlan]) -> (fileGroups: [FileGroup], categorizedGroups: [CategorizedGroup]) {
        var fileGroups: [FileGroup] = []

        for plan in cleaningPlans {
            var groupFiles: [DisplayFile] = []

            for (url, action) in plan.actions {
                let fileSize = getFileSize(url)
                let displayAction: FileAction

                switch action {
                case .keep(let reason):
                    displayAction = .keepAsIs(reason: reason)
                case .delete(let reason):
                    displayAction = .delete(reason: reason)
                }

                let displayFile = DisplayFile(url: url, size: fileSize, action: displayAction)
                groupFiles.append(displayFile)
            }

            if !groupFiles.isEmpty {
                let group = FileGroup(groupName: "Live Photo: \(plan.groupName)", files: groupFiles)
                fileGroups.append(group)
            }
        }

        // åˆ›å»ºåˆ†ç±»ç»„
        let categorizedGroup = CategorizedGroup(
            categoryName: "Live Photo Duplicates",
            groups: fileGroups,
            totalSizeToDelete: fileGroups.flatMap { $0.files }
                .filter { if case .delete = $0.action { return true }; return false }
                .reduce(0) { $0 + $1.size },
            isExpanded: true,
            displayedGroupCount: fileGroups.count
        )

        return (fileGroups: fileGroups, categorizedGroups: [categorizedGroup])
    }

            // æ›´æ–°UIè¿›åº¦ - æ¯ä¸ªå‰©ä½™æ–‡ä»¶å¤„ç†å®Œå°±æ›´æ–°
            await MainActor.run {
                let progress = 0.60 + (Double(currentFile) / Double(remainingFilesSnapshot.count)) * 0.10

                // è®¡ç®—å‰©ä½™æ–‡ä»¶å¤„ç†çš„æ—¶é—´ä¼°ç®—
                let remainingElapsedTime = Date().timeIntervalSince(remainingFilesStartTime)
                var remainingETA: TimeInterval? = nil
                if currentFile > 1 && remainingElapsedTime > 0.2 {
                    let fileProgress = Double(currentFile) / Double(remainingFilesSnapshot.count)
                    let estimatedTotalTime = remainingElapsedTime / fileProgress
                    remainingETA = max(0, estimatedTotalTime - remainingElapsedTime)
                }

                let scanProgress = ScanningProgress(
                    phase: "Phase 2: Live Photo Detection",
                    detail: "Processing \(url.lastPathComponent) (\(currentFile)/\(remainingFilesSnapshot.count))...",
                    progress: progress,
                    totalFiles: allLivePhotoFiles.count + remainingFilesSnapshot.count,
                    processedFiles: allLivePhotoFiles.count + currentFile,
                    estimatedTimeRemaining: remainingETA,
                    processingSpeedMBps: nil,
                    confidence: .medium
                )
                self.state = .scanning(progress: scanProgress, animationRate: 12.0)
            }

            // è®¡ç®—å•ä¸ªå‰©ä½™æ–‡ä»¶çš„å“ˆå¸Œ
            do {
                let hash = try calculateHash(for: url)
                await MainActor.run {
                    urlToHash[url] = hash
                }

                // ä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„æ–¹å¼æŸ¥æ‰¾å’Œä¿®æ”¹ç»„
                await MainActor.run {
                    // æŸ¥æ‰¾æ˜¯å¦æœ‰ç»„åŒ…å«ç›¸åŒå“ˆå¸Œçš„æ–‡ä»¶
                    for j in 0..<mergedGroups.count {
                        let groupHashes = Set(mergedGroups[j].compactMap { urlToHash[$0] })
                        if groupHashes.contains(hash) {
                            mergedGroups[j].append(url)
                            break
                        }
                    }
                }
            } catch {
                print("è®¡ç®—å‰©ä½™æ–‡ä»¶å“ˆå¸Œå¤±è´¥ \(url.path): \(error.localizedDescription)")
                // ç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ªæ–‡ä»¶
            }

            // æ¯ä¸ªæ–‡ä»¶å¤„ç†åè®©å‡ºæ§åˆ¶æƒï¼Œä¿æŒUIå“åº”
            await Task.yield()
            if Task.isCancelled { await MainActor.run { state = .welcome }; return }
        }

        print("ğŸ“¸ æ­¥éª¤4 - æœ€ç»ˆåˆ†ç»„: å…± \(mergedGroups.count) ä¸ªåˆå¹¶åçš„Live Photoç»„")

        // æ ‡è®°æ‰€æœ‰å¤„ç†çš„æ–‡ä»¶
        var pairedURLs: Set<URL> = []
        for group in mergedGroups {
            for url in group {
                pairedURLs.insert(url)
            }
        }

        // ç¬¬äº”æ­¥ï¼šå¤„ç†æ¯ä¸ªåˆå¹¶åçš„ç»„ï¼Œä¿ç•™æœ€å¤§æ–‡ä»¶å¹¶é‡å‘½å
        var plan: [URL: FileAction] = [:]
        var processedURLs: Set<URL> = []
        var finalGroups: [FileGroup] = []

        for (groupIndex, group) in mergedGroups.enumerated() {
            var groupFiles: [DisplayFile] = []

            // åˆ†ç¦»HEICå’ŒMOVæ–‡ä»¶
            let heicFiles = group.filter { $0.pathExtension.lowercased() == "heic" }
            let movFiles = group.filter { $0.pathExtension.lowercased() == "mov" }

            if heicFiles.isEmpty || movFiles.isEmpty {
                print("âš ï¸ è·³è¿‡ç»„ \(groupIndex): ç¼ºå°‘HEICæˆ–MOVæ–‡ä»¶")
                continue
            }

            // æŒ‰æ–‡ä»¶å¤§å°æ’åºï¼Œé€‰æ‹©æœ€å¤§çš„
            let sortedHeicFiles = heicFiles.sorted { ($0.fileSize ?? 0) > ($1.fileSize ?? 0) }
            let sortedMovFiles = movFiles.sorted { ($0.fileSize ?? 0) > ($1.fileSize ?? 0) }

            // æ‰¾åˆ°æœ€çŸ­çš„åŸºç¡€æ–‡ä»¶åï¼ˆç”¨äºé‡å‘½åï¼‰
            let allBaseNames = group.map { getBaseName(for: $0) }
            let shortestBaseName = allBaseNames.min { $0.count < $1.count } ?? allBaseNames.first ?? "Unknown"

            print("ğŸ“¸ å¤„ç†ç»„ \(groupIndex): \(heicFiles.count) HEIC + \(movFiles.count) MOVï¼Œé‡å‘½åä¸º '\(shortestBaseName)'")

            // ä¿ç•™æœ€å¤§çš„HEICæ–‡ä»¶
            if let bestHeic = sortedHeicFiles.first {
                let newName = "\(shortestBaseName).heic"
                plan[bestHeic] = .keepAsIs(reason: "Primary Live Photo image (rename to \(newName))")
                processedURLs.insert(bestHeic)
                groupFiles.append(DisplayFile(url: bestHeic, size: bestHeic.fileSize ?? 0, action: plan[bestHeic]!))
            }

            // ä¿ç•™æœ€å¤§çš„MOVæ–‡ä»¶
            if let bestMov = sortedMovFiles.first {
                let newName = "\(shortestBaseName).mov"
                plan[bestMov] = .keepAsIs(reason: "Primary Live Photo video (rename to \(newName))")
                processedURLs.insert(bestMov)
                groupFiles.append(DisplayFile(url: bestMov, size: bestMov.fileSize ?? 0, action: plan[bestMov]!))
            }

            // åˆ é™¤å…¶ä»–æ‰€æœ‰HEICæ–‡ä»¶
            for duplicateHeic in sortedHeicFiles.dropFirst() {
                plan[duplicateHeic] = .delete(reason: "Duplicate Live Photo image")
                processedURLs.insert(duplicateHeic)
                groupFiles.append(DisplayFile(url: duplicateHeic, size: duplicateHeic.fileSize ?? 0, action: plan[duplicateHeic]!))
            }

            // åˆ é™¤å…¶ä»–æ‰€æœ‰MOVæ–‡ä»¶
            for duplicateMov in sortedMovFiles.dropFirst() {
                plan[duplicateMov] = .delete(reason: "Duplicate Live Photo video")
                processedURLs.insert(duplicateMov)
                groupFiles.append(DisplayFile(url: duplicateMov, size: duplicateMov.fileSize ?? 0, action: plan[duplicateMov]!))
            }

            let deletedCount = (sortedHeicFiles.count - 1) + (sortedMovFiles.count - 1)
            let groupName = if deletedCount > 0 {
                "Live Photo Duplicates: \(shortestBaseName)"
            } else {
                "Perfectly Paired & Ignored: \(shortestBaseName)"
            }

            finalGroups.append(FileGroup(groupName: groupName, files: groupFiles))

            await Task.yield()
            if Task.isCancelled { await MainActor.run { state = .welcome }; return }
        }

        print("ğŸ“¸ Live Photoå¤„ç†å®Œæˆ: \(mergedGroups.count) ä¸ªç»„ï¼Œ\(processedURLs.count) ä¸ªæ–‡ä»¶å·²å¤„ç†")

        // --- PHASE 3: CONTENT ANALYSIS & HASHING ---
        let hashingProgressStart = 0.70  // é˜¶æ®µ2ç»“æŸåœ¨70%
        let hashingProgressEnd = 0.85    // é˜¶æ®µ3ç»“æŸåœ¨85%
        
        var urlToHashMap: [URL: String] = [:]
        var hashToFileURLs: [String: [URL]] = [:]
        
        // Filter out files that are already in Live Photo groups
        let urlsToHash = allMediaFileURLs.filter { !pairedURLs.contains($0) }
        print("ğŸ” Hashing \(urlsToHash.count) files (skipped \(pairedURLs.count) Live Photo files)")

        // --- Parallel Hashing with TaskGroup ---
        let hashingStartTime = Date()
        var processedFilesCount = 0
        let totalFilesToHash = urlsToHash.count
        
        // ä½¿ç”¨å‰é¢å·²å®šä¹‰çš„å¹¶å‘é™åˆ¶
        
        try await withThrowingTaskGroup(of: (URL, String?).self) { group in
            var urlIterator = urlsToHash.makeIterator()
            var activeTasks = 0

            // 1. Start the initial batch of concurrent tasks.
            for _ in 0..<concurrencyLimit {
                if let url = urlIterator.next() {
                    group.addTask { [url] in
                        return autoreleasepool {
                            do {
                                let hash = try calculateHash(for: url)
                                return (url, hash)
                            } catch {
                                print("è®¡ç®—å“ˆå¸Œå¤±è´¥ \(url.path): \(error.localizedDescription)")
                                return (url, nil)
                            }
                        }
                    }
                    activeTasks += 1
                }
            }

            // 2. As each task finishes, process its result and start a new task for the next item.
            for try await (url, hash) in group {
                activeTasks -= 1

                if Task.isCancelled {
                    group.cancelAll()
                    break
                }

                // Process the result of the completed task.
                processedFilesCount += 1
                if let hash = hash {
                    // åœ¨MainActorä¸Šä¸‹æ–‡ä¸­å®‰å…¨ä¿®æ”¹å­—å…¸å’Œæ•°ç»„
                    await MainActor.run {
                        urlToHashMap[url] = hash
                        hashToFileURLs[hash, default: []].append(url)
                    }
                }

                // Add a new task for the next URL from the iterator.
                if let nextURL = urlIterator.next() {
                    group.addTask { [nextURL] in
                        return autoreleasepool {
                            do {
                                let hash = try calculateHash(for: nextURL)
                                return (nextURL, hash)
                            } catch {
                                print("è®¡ç®—å“ˆå¸Œå¤±è´¥ \(nextURL.path): \(error.localizedDescription)")
                                return (nextURL, nil)
                            }
                        }
                    }
                    activeTasks += 1
                }

                // æ¯ä¸ªæ–‡ä»¶å®Œæˆåç«‹å³æ›´æ–°UIï¼ˆæ— èŠ‚æµï¼‰
                let hashingProgress = totalFilesToHash > 0 ? (Double(processedFilesCount) / Double(totalFilesToHash)) : 1.0
                let totalHashingElapsedTime = Date().timeIntervalSince(hashingStartTime)
                var etr: TimeInterval? = nil
                if hashingProgress > 0.005 && totalHashingElapsedTime > 0.3 {
                    let estimatedTotalTime = totalHashingElapsedTime / hashingProgress
                    etr = max(0, estimatedTotalTime - totalHashingElapsedTime)
                }

                // --- Update UI State ---
                let progressVal = hashingProgressStart + hashingProgress * (hashingProgressEnd - hashingProgressStart)

                let progressToUpdate = ScanningProgress(
                    phase: "Phase 3: Content Analysis",
                    detail: "Computing hash for \(url.lastPathComponent) (\(processedFilesCount)/\(totalFilesToHash))...",
                    progress: progressVal,
                    totalFiles: totalFiles,
                    processedFiles: processedFilesCount,
                    estimatedTimeRemaining: etr,
                    processingSpeedMBps: nil,
                    confidence: .medium
                )
                await updateScanState(progressToUpdate, animationRate: 12.0)

                // æ¯å¤„ç†20ä¸ªæ–‡ä»¶å¼ºåˆ¶é‡Šæ”¾å†…å­˜å¹¶æš‚åœ
                if processedFilesCount % 20 == 0 {
                    await Task.yield()
                }
            }
        }
        
        if Task.isCancelled { await MainActor.run { state = .welcome }; return }
        
        // --- PHASE 4: DUPLICATE DETECTION ---
        let analysisProgressStart = hashingProgressEnd  // ä»85%å¼€å§‹
        let analysisProgressEnd = 0.92                  // åœ¨92%ç»“æŸ
        let phase4StartTime = Date()

        await MainActor.run {
            let progress = ScanningProgress(phase: "Phase 4: Duplicate Detection", detail: "Finding content-identical files...", progress: analysisProgressStart, totalFiles: totalFiles, processedFiles: 0, estimatedTimeRemaining: nil, processingSpeedMBps: nil, confidence: .medium)
            self.state = .scanning(progress: progress, animationRate: 15.0) // Fixed moderate speed for planning phase
        }

        // Continue using existing plan, processedURLs, and finalGroups from Live Photo processing

        // --- Merge Live Photo pairs in content duplicates ---
        await MainActor.run {
            let phase4ElapsedTime = Date().timeIntervalSince(phase4StartTime)
            var phase4ETA: TimeInterval? = nil
            if phase4ElapsedTime > 0.1 {
                // é˜¶æ®µ4é€šå¸¸å¾ˆå¿«ï¼Œç»™ä¸€ä¸ªç²—ç•¥ä¼°è®¡
                phase4ETA = max(0, 2.0 - phase4ElapsedTime)
            }

            let progress = ScanningProgress(phase: "Phase 4: Duplicate Detection", detail: "Merging Live Photo duplicate groups...", progress: analysisProgressStart + 0.02, totalFiles: totalFiles, processedFiles: processedURLs.count, estimatedTimeRemaining: phase4ETA, processingSpeedMBps: nil, confidence: .medium)
            self.state = .scanning(progress: progress, animationRate: 15.0)
        }

        // Find Live Photo pairs in duplicate groups and merge them
        var mergedHashToFileURLs = hashToFileURLs
        var mergedHashes: Set<String> = []

        for (hash1, urls1) in hashToFileURLs {
            if mergedHashes.contains(hash1) || urls1.count <= 1 { continue }

            // Check if this group contains image files
            let hasImages = urls1.contains { url in
                let ext = url.pathExtension.lowercased()
                return ext == "heic" || ext == "jpg" || ext == "jpeg"
            }

            if hasImages {
                // Look for corresponding MOV files with same base names
                let baseNames = Set(urls1.map { $0.deletingPathExtension().lastPathComponent })

                // Find hash groups that contain MOV files with matching base names
                for (hash2, urls2) in hashToFileURLs {
                    if hash2 == hash1 || mergedHashes.contains(hash2) || urls2.count <= 1 { continue }

                    let hasMOVs = urls2.contains { url in
                        url.pathExtension.lowercased() == "mov"
                    }

                    if hasMOVs {
                        let movBaseNames = Set(urls2.map { $0.deletingPathExtension().lastPathComponent })

                        // Check if there are any matching base names (partial or complete overlap)
                        let overlappingNames = baseNames.intersection(movBaseNames)
                        if !overlappingNames.isEmpty {
                            print("ğŸ“¸ Merging Live Photo duplicate groups (partial match):")
                            print("  HEIC group (\(hash1)): \(urls1.map { $0.lastPathComponent })")
                            print("  MOV group (\(hash2)): \(urls2.map { $0.lastPathComponent })")
                            print("  Overlapping names: \(overlappingNames)")

                            // Merge the groups using the first hash as the key
                            mergedHashToFileURLs[hash1] = urls1 + urls2
                            mergedHashToFileURLs.removeValue(forKey: hash2)
                            mergedHashes.insert(hash1)
                            mergedHashes.insert(hash2)

                            print("  âœ… Merged into single group with \(mergedHashToFileURLs[hash1]?.count ?? 0) files")
                            break
                        }
                    }
                }
            }
        }


        // Process content-identical files first
        let contentDuplicateGroups = mergedHashToFileURLs.filter { $0.value.count > 1 }
        let duplicateGroupsArray = Array(contentDuplicateGroups)
        for (hash, urls) in duplicateGroupsArray {
            if Task.isCancelled { await MainActor.run { state = .welcome }; return }

            var groupFiles: [DisplayFile] = []

            // Check if this is a merged Live Photo group
            let images = urls.filter { url in
                let ext = url.pathExtension.lowercased()
                return ext == "heic" || ext == "jpg" || ext == "jpeg"
            }
            let videos = urls.filter { url in
                url.pathExtension.lowercased() == "mov"
            }

            let hasImages = !images.isEmpty
            let hasMOVs = !videos.isEmpty

            if hasImages && hasMOVs {
                // This is a merged Live Photo group - keep one image and one video
                let sortedImages = images.sorted { $0.lastPathComponent.count < $1.lastPathComponent.count }
                let sortedVideos = videos.sorted { $0.lastPathComponent.count < $1.lastPathComponent.count }

                // Keep the best image
                if let bestImage = sortedImages.first {
                    plan[bestImage] = .keepAsIs(reason: "Primary Live Photo image")
                    processedURLs.insert(bestImage)
                    groupFiles.append(DisplayFile(url: bestImage, size: bestImage.fileSize ?? 0, action: plan[bestImage]!))
                }

                // Keep the best video
                if let bestVideo = sortedVideos.first {
                    plan[bestVideo] = .keepAsIs(reason: "Primary Live Photo video")
                    processedURLs.insert(bestVideo)
                    groupFiles.append(DisplayFile(url: bestVideo, size: bestVideo.fileSize ?? 0, action: plan[bestVideo]!))
                }

                // Delete all other images
                for imageToDelete in sortedImages.dropFirst() {
                    plan[imageToDelete] = .delete(reason: "Duplicate Live Photo image")
                    processedURLs.insert(imageToDelete)
                    groupFiles.append(DisplayFile(url: imageToDelete, size: imageToDelete.fileSize ?? 0, action: plan[imageToDelete]!))
                }

                // Delete all other videos
                for videoToDelete in sortedVideos.dropFirst() {
                    plan[videoToDelete] = .delete(reason: "Duplicate Live Photo video")
                    processedURLs.insert(videoToDelete)
                    groupFiles.append(DisplayFile(url: videoToDelete, size: videoToDelete.fileSize ?? 0, action: plan[videoToDelete]!))
                }
            } else {
                // Regular content duplicate group - keep only one file
                let sortedURLs = urls.sorted { $0.lastPathComponent.count < $1.lastPathComponent.count }
                guard let fileToKeep = sortedURLs.first else { continue }

                plan[fileToKeep] = .keepAsIs(reason: "Best name among content duplicates")
                processedURLs.insert(fileToKeep)
                groupFiles.append(DisplayFile(url: fileToKeep, size: fileToKeep.fileSize ?? 0, action: plan[fileToKeep]!))

                for urlToDelete in sortedURLs.dropFirst() {
                    plan[urlToDelete] = .delete(reason: "Content Duplicate of \(fileToKeep.lastPathComponent)")
                    processedURLs.insert(urlToDelete)
                    groupFiles.append(DisplayFile(url: urlToDelete, size: urlToDelete.fileSize ?? 0, action: plan[urlToDelete]!))
                }
            }

            let groupName: String
            if hasImages && hasMOVs {
                // This is a merged Live Photo group - use the first URL to get base name
                let baseName = urls.first?.deletingPathExtension().lastPathComponent ?? "Unknown"
                groupName = "Live Photo Duplicates: \(baseName)"
            } else {
                groupName = "Content Duplicates: \(hash)"
            }

            finalGroups.append(FileGroup(groupName: groupName, files: groupFiles))
        }

        // Live Photo pairs are now handled by the merge logic above


        // --- PHASE 5: BUILDING CLEANING PLAN ---
        let planningProgressStart = analysisProgressEnd  // ä»92%å¼€å§‹
        let planningProgressEnd = 0.97                   // åœ¨97%ç»“æŸ
        let phase5StartTime = Date()

        let processedAfterDuplicates = processedURLs.count
        let nameAnalysisProgress = planningProgressStart + (planningProgressEnd - planningProgressStart) * 0.2
        await MainActor.run {
            // é˜¶æ®µ5å¾ˆå¿«ï¼Œç»™ä¸€ä¸ªç®€å•çš„ä¼°è®¡
            let phase5ETA: TimeInterval = 1.0

            let progress = ScanningProgress(phase: "Phase 5: Building Plan", detail: "Isolating unique files...", progress: nameAnalysisProgress, totalFiles: totalFiles, processedFiles: processedAfterDuplicates, estimatedTimeRemaining: phase5ETA, processingSpeedMBps: nil, confidence: .medium)
            self.state = .scanning(progress: progress, animationRate: 15.0)
        }
        await Task.yield() // Ensure UI updates

        var remainingURLs: [URL] = []
        remainingURLs.reserveCapacity(allMediaFileURLs.count - processedURLs.count)
        for (index, url) in allMediaFileURLs.enumerated() {
            if !processedURLs.contains(url) {
                remainingURLs.append(url)
            }
            if index % 5000 == 0 { // Yield to keep UI responsive
                await Task.yield()
                if Task.isCancelled { await MainActor.run { state = .welcome }; return }
            }
        }

        // --- Process remaining files (fallback for edge cases) ---
        let finalProgress = planningProgressStart + (planningProgressEnd - planningProgressStart) * 0.8
        await MainActor.run {
            let phase5ElapsedTime = Date().timeIntervalSince(phase5StartTime)
            let phase5ETA = max(0, 0.5 - phase5ElapsedTime)

            let progress = ScanningProgress(phase: "Phase 5: Building Plan", detail: "Processing remaining files...", progress: finalProgress, totalFiles: totalFiles, processedFiles: processedURLs.count, estimatedTimeRemaining: phase5ETA, processingSpeedMBps: nil, confidence: .medium)
            self.state = .scanning(progress: progress, animationRate: 15.0)
        }
        await Task.yield()

        // Note: remainingURLs should be mostly empty at this point since Live Photos are processed in Phase 2
        // and content duplicates are processed in Phase 3-4. This is mainly a safety net for edge cases.
        
        // --- FINALIZATION ---
        let trulyLeftoverURLs = allMediaFileURLs.filter { !processedURLs.contains($0) }
        for url in trulyLeftoverURLs {
             plan[url] = .keepAsIs(reason: "Unique file")
        }
        
        if Task.isCancelled { await MainActor.run { state = .welcome }; return }
        
        // --- PHASE 6: FINALIZATION & RESULTS ---
        await MainActor.run {
            let progress = ScanningProgress(phase: "Phase 6: Finalization", detail: "Found \(finalGroups.count) groups.", progress: 1.0, totalFiles: totalFiles, processedFiles: totalFiles, estimatedTimeRemaining: nil, processingSpeedMBps: nil, confidence: .medium)
            self.state = .scanning(progress: progress, animationRate: 5.0) // Calm down before switching view
        }
        
        try? await Task.sleep(nanoseconds: 500_000_000) // 0.5s to show complete
        
        await MainActor.run {
            // New sorting logic based on categories
            let order: [String: Int] = [
                "Content Duplicates": 1,
                "Live Photo Duplicates": 2,
                "Perfectly Paired & Ignored": 3
            ]

            let sortedGroups = finalGroups.sorted { g1, g2 in
                func category(for groupName: String) -> (Int, String) {
                    // Handle Live Photo Duplicates as separate category
                    if groupName.starts(with: "Live Photo Duplicates:") {
                        let baseName = groupName.replacingOccurrences(of: "Live Photo Duplicates: ", with: "")
                        return (order["Live Photo Duplicates"]!, baseName)
                    }

                    // Handle standard categories
                    for (prefix, orderValue) in order {
                        if groupName.starts(with: prefix) {
                            let baseName = groupName.replacingOccurrences(of: "\(prefix): ", with: "")
                            return (orderValue, baseName)
                        }
                    }

                    // Default fallback for any unmatched groups
                    return (99, groupName)
                }

                let (order1, name1) = category(for: g1.groupName)
                let (order2, name2) = category(for: g2.groupName)

                if order1 != order2 {
                    return order1 < order2
                }
                
                return name1.localizedCaseInsensitiveCompare(name2) == .orderedAscending
            }
            
            // This is the new, one-time categorization step.
            let groupedByCat = Dictionary(grouping: sortedGroups, by: { getCategoryPrefix(for: $0.groupName) })
            
            let categorized = groupedByCat.map { categoryName, groupsInCat -> CategorizedGroup in
                let totalSizeToDelete = groupsInCat.flatMap { $0.files }
                    .filter { !$0.action.isKeep }
                    .reduce(0) { $0 + $1.size }
                
                var category = CategorizedGroup(
                    id: categoryName,
                    categoryName: categoryName,
                    groups: groupsInCat,
                    totalSizeToDelete: totalSizeToDelete
                )
                
                // Collapse the "Ignored" group by default
                if categoryName.starts(with: "Perfectly Paired") {
                    category.isExpanded = false
                }
                
                return category
            }.sorted {
                let order1 = order[$0.categoryName] ?? 99
                let order2 = order[$1.categoryName] ?? 99
                return order1 < order2
            }
            
            self.showResults(groups: sortedGroups, categorizedGroups: categorized)
            let (elapsed, _) = progressManager.getOverallProgress()
            print("Scan finished in \(elapsed) seconds.")
        }
    }
    
    private func resetToWelcomeState() {
        // Reset state before switching views to prevent crashes.
        // The order is important: clear selection first, then data, then switch view state.
        self.selectedFile = nil
        self.allResultGroups = []
        self.masterCategorizedGroups = []
        self.displayItems = []
        self.originalFileActions = [:]
        self.state = .welcome
    }

    /// å®‰å…¨çš„UIçŠ¶æ€æ›´æ–°ï¼Œæ£€æŸ¥å–æ¶ˆæ ‡è®°é˜²æ­¢ç«äº‰æ¡ä»¶
    private func updateScanState(_ progress: ScanningProgress, animationRate: Double) async {
        await MainActor.run {
            // å¦‚æœç”¨æˆ·å·²è¯·æ±‚å–æ¶ˆï¼Œä¸è¦æ›´æ–°UIçŠ¶æ€
            if !isCancelRequested {
                self.state = .scanning(progress: progress, animationRate: animationRate)
            }
        }
    }
    
    private func showResults(groups: [FileGroup], categorizedGroups: [CategorizedGroup]) {
        self.allResultGroups = groups
        self.masterCategorizedGroups = categorizedGroups
        
        // Store the original, AI-determined actions so we can revert back to "Automatic"
        self.originalFileActions = Dictionary(
            uniqueKeysWithValues: groups.flatMap { $0.files }.map { ($0.id, $0.action) }
        )
        
        rebuildDisplayItems()
        self.state = .results
    }
    
    // MARK: - Display & Interaction Logic
    
    /// Rebuilds the entire flattened `displayItems` array from the `masterCategorizedGroups`.
    private func rebuildDisplayItems() {
        var items: [ResultDisplayItem] = []
        for category in masterCategorizedGroups {
            items.append(.categoryHeader(
                id: category.id,
                title: category.categoryName,
                groupCount: category.groups.count,
                size: category.totalSizeToDelete,
                isExpanded: category.isExpanded
            ))

            if category.isExpanded {
                let displayedGroups = category.groups.prefix(category.displayedGroupCount)
                items.append(contentsOf: displayedGroups.map { .fileGroup($0) })

                if category.groups.count > category.displayedGroupCount {
                    items.append(.loadMore(categoryId: category.id))
                }
            }
        }
        self.displayItems = items
    }
    
    private func toggleCategory(categoryId: String) {
        guard let index = masterCategorizedGroups.firstIndex(where: { $0.id == categoryId }),
              index < masterCategorizedGroups.count else {
            print("âš ï¸ åˆ†ç±»ä¸å­˜åœ¨æˆ–ç´¢å¼•è¶Šç•Œï¼Œæ— æ³•åˆ‡æ¢å±•å¼€çŠ¶æ€")
            return
        }
        masterCategorizedGroups[index].isExpanded.toggle()
        rebuildDisplayItems()
    }

    private func loadMoreInCategory(categoryId: String) {
        guard let index = masterCategorizedGroups.firstIndex(where: { $0.id == categoryId }),
              index < masterCategorizedGroups.count else {
            print("âš ï¸ åˆ†ç±»ä¸å­˜åœ¨æˆ–ç´¢å¼•è¶Šç•Œï¼Œæ— æ³•åŠ è½½æ›´å¤š")
            return
        }
        let currentCount = masterCategorizedGroups[index].displayedGroupCount
        let maxGroups = masterCategorizedGroups[index].groups.count
        masterCategorizedGroups[index].displayedGroupCount = min(currentCount + categoryPageSize, maxGroups)
        rebuildDisplayItems()
    }
    
    /// Extracts a base name from a URL for grouping.
    private func getBaseName(for url: URL) -> String {
        let name = url.deletingPathExtension().lastPathComponent
        // æ‰©å±•æ­£åˆ™è¡¨è¾¾å¼ä»¥æ”¯æŒä¸­æ–‡æ¨¡å¼å’Œæ›´å¤šå˜ä½“
        let cleanName = name.replacingOccurrences(of: "(?:[ _-](?:copy|\\d{1,2}|å‰¯æœ¬\\d*)| \\(\\d+\\)|_v\\d{1,2}|_å‰¯æœ¬\\d*)$", with: "", options: [.regularExpression, .caseInsensitive])
        print("ğŸ” BaseName: '\(name)' -> '\(cleanName)'")
        return cleanName
    }

    private func getCategoryPrefix(for groupName: String) -> String {
        let categoryOrder: [String: Int] = [
            "Content Duplicates": 1,
            "Live Photo Duplicates": 2,
            "Perfectly Paired & Ignored": 3
        ]

        // Live Photo Duplicates should be treated as separate category
        if groupName.starts(with: "Live Photo Duplicates:") {
            return "Live Photo Duplicates"
        }

        for prefix in categoryOrder.keys where groupName.starts(with: prefix) {
            return prefix
        }
        return "Other"
    }

    /// æ˜¾ç¤ºé”™è¯¯æ¢å¤å¯¹è¯æ¡†
    private func showErrorRecovery(
        title: String,
        message: String,
        technicalDetails: String? = nil,
        context: ErrorContext? = nil
    ) {
        let error = DetailedError(
            title: title,
            message: message,
            technicalDetails: technicalDetails,
            canContinue: context?.canSkipFile ?? false
        )

        currentError = error
        errorContext = context
        showErrorDialog = true
    }

    /// ç»Ÿä¸€çš„è¿›åº¦æ›´æ–°å‡½æ•°
    private func updateProgress(completed: Int, detail: String, totalFiles: Int) async {
        let scanProgress = progressManager.updateProgress(
            completed: completed,
            detail: detail,
            totalFiles: totalFiles
        )
        await updateScanState(scanProgress, animationRate: 12.0)
    }

    /// å¼€å§‹æ–°çš„æ‰«æé˜¶æ®µ
    private func startPhase(_ phase: ScanPhase, totalWork: Int) {
        progressManager.startPhase(phase, totalWork: totalWork)
    }

    /// æ›´æ–°é˜¶æ®µæ€»å·¥ä½œé‡
    private func updateTotalWork(_ newTotal: Int) {
        progressManager.updateTotalWork(newTotal)
    }

    /// å¤„ç†æ–‡ä»¶è®¡ç®—é”™è¯¯
    private func handleFileProcessingError(
        _ error: Error,
        fileURL: URL,
        phase: String,
        processedFiles: Int,
        totalFiles: Int,
        canSkip: Bool = true
    ) async {
        await MainActor.run {
            let context = ErrorContext(
                fileURL: fileURL,
                currentPhase: phase,
                totalFiles: totalFiles,
                processedFiles: processedFiles,
                canSkipFile: canSkip,
                resumeOperation: nil
            )

            let title = "æ–‡ä»¶å¤„ç†é”™è¯¯"
            var message = "å¤„ç†æ–‡ä»¶æ—¶é‡åˆ°é—®é¢˜"
            var technicalDetails: String? = nil

            if let hashError = error as? HashCalculationError {
                switch hashError {
                case .fileNotAccessible:
                    message = "æ— æ³•è®¿é—®æ–‡ä»¶ï¼Œå¯èƒ½æ˜¯æƒé™é—®é¢˜ã€‚"
                case .fileNotReadable:
                    message = "æ–‡ä»¶æ— æ³•è¯»å–ï¼Œå¯èƒ½æ–‡ä»¶å·²æŸåæˆ–è¢«å…¶ä»–ç¨‹åºå ç”¨ã€‚"
                case .fileSizeError:
                    message = "æ— æ³•è·å–æ–‡ä»¶å¤§å°ä¿¡æ¯ã€‚"
                case .readError:
                    message = "è¯»å–æ–‡ä»¶æ•°æ®æ—¶å‡ºé”™ã€‚"
                case .unknownError:
                    message = "å¤„ç†æ–‡ä»¶æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯ã€‚"
                }
                technicalDetails = hashError.localizedDescription
            } else {
                technicalDetails = error.localizedDescription
            }

            showErrorRecovery(
                title: title,
                message: message,
                technicalDetails: technicalDetails,
                context: context
            )
        }
    }

    private func updateUserAction(for file: DisplayFile) {
        guard let originalAction = originalFileActions[file.id] else { return }

        let newAction: FileAction

        // If the current action is a user override, the next state is to revert to the original automatic action.
        if file.action.isUserOverride {
            newAction = originalAction
        } else {
            // If the current action is the automatic one, the next state is the user override.
            // The override is the opposite of the original action.
            if originalAction.isKeep {
                newAction = .userDelete
            } else {
                newAction = .userKeep
            }
        }

        // --- Find and update the file in all data sources ---
        
        // å®‰å…¨çš„æ•°ç»„æ›´æ–°ï¼Œæ·»åŠ è¾¹ç•Œæ£€æŸ¥
        guard let groupIndex = allResultGroups.firstIndex(where: { $0.files.contains(where: { $0.id == file.id }) }),
              groupIndex < allResultGroups.count,
              let fileIndex = allResultGroups[groupIndex].files.firstIndex(where: { $0.id == file.id }),
              fileIndex < allResultGroups[groupIndex].files.count else {
            print("âš ï¸ æ— æ³•æ‰¾åˆ°è¦æ›´æ–°çš„æ–‡ä»¶ï¼Œå¯èƒ½å·²è¢«åˆ é™¤")
            return
        }

        // 1. Update the master list of all files
        allResultGroups[groupIndex].files[fileIndex].action = newAction

        // 2. Find which category this group belongs to
        let groupName = allResultGroups[groupIndex].groupName
        let categoryName = getCategoryPrefix(for: groupName)

        // 3. Update the corresponding category in the master categorized list
        guard let catIndex = masterCategorizedGroups.firstIndex(where: { $0.id == categoryName }),
              catIndex < masterCategorizedGroups.count else {
            print("âš ï¸ æ— æ³•æ‰¾åˆ°å¯¹åº”çš„åˆ†ç±»ï¼Œè·³è¿‡åˆ†ç±»æ›´æ–°")
            rebuildDisplayItems()
            return
        }

        guard let masterGroupIndex = masterCategorizedGroups[catIndex].groups.firstIndex(where: { $0.id == allResultGroups[groupIndex].id }),
              masterGroupIndex < masterCategorizedGroups[catIndex].groups.count,
              let masterFileIndex = masterCategorizedGroups[catIndex].groups[masterGroupIndex].files.firstIndex(where: { $0.id == file.id }),
              masterFileIndex < masterCategorizedGroups[catIndex].groups[masterGroupIndex].files.count else {
            print("âš ï¸ æ— æ³•æ‰¾åˆ°åˆ†ç±»ä¸­çš„æ–‡ä»¶ï¼Œå¯èƒ½æ•°æ®ä¸åŒæ­¥")
            rebuildDisplayItems()
            return
        }

        masterCategorizedGroups[catIndex].groups[masterGroupIndex].files[masterFileIndex].action = newAction

        // 4. Recalculate the total size to delete for the updated category
        let newTotalSize = masterCategorizedGroups[catIndex].groups.flatMap { $0.files }
            .filter { !$0.action.isKeep }
            .reduce(0) { $0 + $1.size }
        masterCategorizedGroups[catIndex].totalSizeToDelete = newTotalSize

        // 5. Rebuild the display list to reflect the change
        rebuildDisplayItems()
    }

}


#if os(macOS)
// MARK: - Preview
#Preview {
    ContentView()
}
#endif 